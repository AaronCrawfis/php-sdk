<?php

namespace Dapr\Dev;

use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpFile;

/**
 * Class GrpcUpgrader
 * @package Dapr\Dev
 */
class GrpcUpgrader
{
    protected const BASE_DIR = __DIR__.'/../src/grpc-generated';
    protected ClassType $class;

    public function __construct(public string $file, public string $name)
    {
        $this->class = ClassType::withBodiesFrom($name);
    }

    public static function upgrade()
    {
        $files = self::get_files(self::BASE_DIR);
        foreach ($files as $file) {
            if (str_contains($file, 'GPBMetadata')) {
                continue;
            }
            $class    = self::get_class_name($file);
            $upgrader = new GrpcUpgrader($file, $class);
            $upgrader->do_upgrade();
        }
    }

    /**
     * @param string $dir
     *
     * @return array
     */
    public static function get_files(string $dir): array
    {
        $files           = scandir($dir);
        $files_to_return = [];
        foreach ($files as $file) {
            if (in_array($file, ['.', '..'])) {
                continue;
            }
            $file = "$dir/$file";
            if (is_dir($file)) {
                $files_to_return = array_merge($files_to_return, self::get_files($file));
            }
            if (is_file($file)) {
                $files_to_return[] = $file;
            }
        }

        return $files_to_return;
    }

    public static function get_class_name(string $file): string
    {
        $class = str_replace(self::BASE_DIR, '', $file);
        $class = str_replace('.php', '', $class);
        $class = str_replace('/', '\\', $class);

        return $class;
    }

    public function do_upgrade(): void
    {
        echo "Enriching: {$this->name}\n";
        $this->enrich_methods();
        $this->write_file();
    }

    protected function enrich_methods(): void
    {
        foreach ($this->class->getMethods() as $method) {
            $return = $method->getReturnType() ?? $this->extract_tag($method->getComment(), '@return')['type'] ?? null;
            if ($return === null && $method->getName() !== '__construct' && ! str_contains(
                    $method->getBody(),
                    'return'
                )) {
                $return = 'void';
            }
            if ($return === null && str_contains($method->getBody(), 'return isset') && ! str_contains(
                    $method->getBody(),
                    "\n"
                )) {
                $return = 'bool';
            }
            $method->setReturnType($this->sanitize_type($return));

            foreach ($method->getParameters() as $parameter) {
                $type = $parameter->getType() ?? $this->extract_param_type(
                        $method->getComment(),
                        $parameter->getName()
                    );
                if ($method->getName() === '__construct' && $parameter->getName() === 'opts') {
                    $type = 'mixed';
                }
                $parameter->setType($this->sanitize_type($type));
                if ($type && $parameter->hasDefaultValue() && $parameter->getDefaultValue() === null) {
                    $parameter->setType($type.'|null');
                }
            }
        }
    }

    protected function extract_tag(string $doc, string $tag): array
    {
        preg_match('/'.$tag.' (?<type>\S+)\s*(?<name>\S+)*/m', $doc, $output_array);

        return $output_array;
    }

    protected function sanitize_type(string|null $types): string|null
    {
        $returns = [];
        if ($types === null) {
            return $types;
        }
        foreach (explode('|', $types) as $returnable) {
            $returns[] = match ($returnable) {
                default => str_ends_with($returnable, '[]') ? 'array' : $returnable,
                '$this' => $this->name
            };
        }

        return implode('|', $returns);
    }

    protected function extract_param_type(string $doc, string $param): null|string
    {
        preg_match('/@param (?<type>\S+)\s+\$'.$param.'/m', $doc, $output_array);

        return $output_array['type'] ?? null;
    }

    protected function write_file(): void
    {
        $file = new PhpFile();
        $file->addComment('This file is automatically generated by `composer build-grpc`');
        $namespace = substr(str_replace('/', '\\', dirname(str_replace('\\', '/', $this->name))), 1);
        $namespace = $file->addNamespace($namespace);
        $namespace->add($this->class);
        file_put_contents($this->file, $file);
    }

    public static function add_interfaces()
    {
        $files = self::get_files(self::BASE_DIR);
        foreach ($files as $file) {
            if (str_contains($file, 'GPBMetadata')) {
                continue;
            }
            $class    = self::get_class_name($file);
            $upgrader = new GrpcUpgrader($file, $class);
            $upgrader->create_interface();
        }
    }

    protected function create_interface(): string
    {
        $builder = new InterfaceBuilder($this->name);
        echo "Generating Interface: {$this->name}\n";

        return $builder->write_interface($builder->build());
    }
}
